// Configurações
const config = {
    csvUrl: 'https://raw.githubusercontent.com/SEU_USUARIO/SEU_REPOSITORIO/main/vazamentos.csv',
    defaultView: [-15.6427, -56.1722],
    defaultZoom: 15,
    refreshInterval: 300000 // 5 minutos
};

// Variáveis globais
let map;
let markers = {};
let vazamentosData = [];

// Inicialização do mapa
function initMap() {
    map = L.map('map').setView(config.defaultView, config.defaultZoom);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);
}

// Ícones personalizados
const icons = {
    pendente: L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41]
    }),
    realizado: L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41]
    })
};

// Carregar dados do CSV
async function loadCSVData() {
    try {
        const timestamp = new Date().getTime();
        const response = await fetch(`${config.csvUrl}?t=${timestamp}`);
        const csvData = await response.text();
        
        Papa.parse(csvData, {
            header: true,
            skipEmptyLines: true,
            complete: function(results) {
                vazamentosData = results.data.map(item => ({
                    id: item.id,
                    local: item.local,
                    coordenadas: [parseFloat(item.lat), parseFloat(item.lng)],
                    status: item.status,
                    dataRegistro: item.data_registro,
                    dataReparo: item.data_reparo || null,
                    descricao: item.descricao
                }));
                
                updateMapAndList();
                updateStatusMessage(results.data.length);
            },
            error: function(error) {
                console.error("Erro ao processar CSV:", error);
                document.getElementById('loadingStatus').textContent = "Erro ao processar arquivo CSV";
            }
        });
    } catch (error) {
        console.error("Erro ao carregar CSV:", error);
        document.getElementById('loadingStatus').textContent = "Erro ao carregar arquivo CSV";
    }
}

// Atualizar mapa e lista
function updateMapAndList(filter = 'todos') {
    // Limpar marcadores existentes
    map.eachLayer(layer => {
        if (layer instanceof L.Marker) {
            map.removeLayer(layer);
        }
    });
    
    // Filtrar dados
    const filteredData = filter === 'todos' 
        ? vazamentosData 
        : vazamentosData.filter(v => v.status === filter);
    
    // Adicionar novos marcadores
    filteredData.forEach(vazamento => {
        const coords = vazamento.coordenadas;
        const status = vazamento.status.toLowerCase();
        
        L.marker(coords, {
            icon: icons[status]
        }).addTo(map).bindPopup(createPopupContent(vazamento));
    });
    
    // Atualizar lista
    updateVazamentoList(filter);
}

function createPopupContent(vazamento) {
    return `
        <b>${vazamento.local}</b><br>
        Status: <span class="status-${vazamento.status}">${vazamento.status.toUpperCase()}</span><br>
        ${vazamento.descricao}<br>
        <small>Registrado em: ${vazamento.dataRegistro}</small>
        ${vazamento.dataReparo ? `<br><small>Reparado em: ${vazamento.dataReparo}</small>` : ''}
    `;
}

function updateVazamentoList(filter = 'todos') {
    const listContainer = document.getElementById('vazamentoList');
    listContainer.innerHTML = '';
    
    const filteredData = filter === 'todos' 
        ? vazamentosData 
        : vazamentosData.filter(v => v.status === filter);
    
    filteredData.forEach(vazamento => {
        const item = document.createElement('div');
        item.className = `vazamento-item ${vazamento.status}`;
        item.innerHTML = `
            <div>
                <strong>${vazamento.local}</strong>
                <span class="status-badge status-${vazamento.status}">
                    ${vazamento.status.toUpperCase()}
                </span>
            </div>
            <div class="coordinates">${vazamento.coordenadas[0].toFixed(6)}, ${vazamento.coordenadas[1].toFixed(6)}</div>
            <div>${vazamento.descricao}</div>
            <small>Registrado em: ${vazamento.dataRegistro}</small>
        `;
        
        item.addEventListener('click', () => {
            map.setView(vazamento.coordenadas, 18);
            // Abrir popup (precisa armazenar referência dos marcadores para isso)
        });
        
        listContainer.appendChild(item);
    });
}

function updateStatusMessage(count) {
    document.getElementById('loadingStatus').textContent = 
        `Dados carregados com sucesso! ${count} vazamentos`;
}

// Event listeners para filtros
document.getElementById('todos').addEventListener('click', () => {
    setActiveButton('todos');
    updateMapAndList('todos');
});

document.getElementById('pendentes').addEventListener('click', () => {
    setActiveButton('pendentes');
    updateMapAndList('pendente');
});

document.getElementById('realizados').addEventListener('click', () => {
    setActiveButton('realizados');
    updateMapAndList('realizado');
});

function setActiveButton(activeId) {
    document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    document.getElementById(activeId).classList.add('active');
}

// Inicialização
document.addEventListener('DOMContentLoaded', () => {
    initMap();
    loadCSVData();
    
    // Atualizar automaticamente
    setInterval(loadCSVData, config.refreshInterval);
});
